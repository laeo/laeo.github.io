<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Phps on LAEO</title><link>https://laeo.github.io/php/</link><description>Recent content in Phps on LAEO</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 11 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://laeo.github.io/php/index.xml" rel="self" type="application/rss+xml"/><item><title>Eloquent模型子类MorphToMany调用doesntHave失效问题</title><link>https://laeo.github.io/php/eloquent%E6%A8%A1%E5%9E%8B%E5%AD%90%E7%B1%BBmorphtomany%E8%B0%83%E7%94%A8doesnthave%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate><guid>https://laeo.github.io/php/eloquent%E6%A8%A1%E5%9E%8B%E5%AD%90%E7%B1%BBmorphtomany%E8%B0%83%E7%94%A8doesnthave%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="编写bug之路">编写BUG之路&lt;/h2>
&lt;p>在私人项目中使用了 &lt;code>laravel-permission&lt;/code> 包做权限管理，用户表 &lt;code>users&lt;/code> 需要扩展出不同的角色。考虑到项目规模，我将用户数据和后台客服数据统一存放在用户表中，然后根据角色信息来判断账户的归类。如此，我在 &lt;code>App\User&lt;/code> 模型中进行登录认证等统一的用户操作，但是新建 &lt;code>App\Client&lt;/code> 模型来专门管理普通用户的数据，该类继承自用户模型类，可以方便的共享一些通用属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">namespace&lt;/span> App;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">Client&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">extends&lt;/span> User
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">protected&lt;/span> &lt;span style="color:#00688b">$table&lt;/span> = &lt;span style="color:#cd5555">&amp;#39;users&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了方便使用用户模型查找数据，我在 &lt;code>App\Client&lt;/code> 中增加了 &lt;code>全局作用域&lt;/code> 来自动过滤有权限的用户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// 在 app/Client.php 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>&lt;span style="color:#8b008b;font-weight:bold">static&lt;/span>::&lt;span style="color:#658b00">addGlobalScope&lt;/span>(&lt;span style="color:#cd5555">&amp;#39;client&amp;#39;&lt;/span>, &lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> (Builder &lt;span style="color:#00688b">$builder&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$builder&lt;/span>-&amp;gt;&lt;span style="color:#658b00">doesntHave&lt;/span>(&lt;span style="color:#cd5555">&amp;#39;roles&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原本我以为加上上述代码后，就可以正常取出没有权限的普通账户了，可惜事实并非如此，该作用域完全没有起到作用，所有用户数据都被取出来了。我写了一个BUG！&lt;/p>
&lt;h2 id="解决bug之路">解决BUG之路&lt;/h2>
&lt;p>出现这样的问题，首先想到的就是去该包的 issue 页面搜索，看看有没有相关的资料，可能是我关键词有问题，并没有搜索到相关资料。搜索引擎也是相同的结果，没查到 &lt;code>doesntHave&lt;/code> 失效的原因。&lt;/p>
&lt;p>那就只能自己动手咯。&lt;/p>
&lt;p>首先想到打印执行的 SQL 出来看看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">// app/Providers/EventServiceProvider.php 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DB::&lt;span style="color:#658b00">listen&lt;/span>(&lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> (&lt;span style="color:#00688b">$query&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Log::&lt;span style="color:#658b00">debug&lt;/span>(&lt;span style="color:#00688b">$query&lt;/span>-&amp;gt;&lt;span style="color:#658b00">time&lt;/span> . &lt;span style="color:#cd5555">&amp;#39;@&amp;#39;&lt;/span> . &lt;span style="color:#00688b">$query&lt;/span>-&amp;gt;&lt;span style="color:#658b00">sql&lt;/span>, &lt;span style="color:#00688b">$query&lt;/span>-&amp;gt;&lt;span style="color:#658b00">bindings&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过注册上述监听器后，在日志文件中找到了相关的 SQL 记录。看了下提交的参数，其中有个 &lt;code>App\\Client&lt;/code> 引起我的注意，在我从数据库中查询到的数据里，都是存储的原始的 &lt;code>App\User&lt;/code> ，那么只需要将这个参数改正确就行了。我猜测是因为普通用户的模型是继承的，多对多关联的代码在执行的时候自动获取了当前实例的类名，所以才导致查询不到记录。&lt;/p>
&lt;p>找到问题所在就好办了，编辑器里跟着源码挨个跳转，最终找到了它&lt;/p>
&lt;p>&lt;img src="https://laeo.github.io/static/images/2018-08-11-eloquent-morphToMany.png" alt="screenshot">&lt;/p>
&lt;p>在 &lt;code>Illuminate\Database\Eloquent\Relations\MorphToMany&lt;/code> 中我找到了一个关键函数 &lt;code>getMorphClass&lt;/code> ，这货就是给多对多关联提供模型类名的，所以我果断在 &lt;code>App\Client&lt;/code> 中重写了该方法，以使之返回固定的 &lt;code>App\User&lt;/code> 。&lt;/p></description></item><item><title>使用Docker快速构建Laravel开发环境</title><link>https://laeo.github.io/php/%E4%BD%BF%E7%94%A8docker%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAlaravel%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Fri, 21 Oct 2016 00:00:00 +0000</pubDate><guid>https://laeo.github.io/php/%E4%BD%BF%E7%94%A8docker%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAlaravel%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>&lt;h2 id="docker简介">Docker简介&lt;/h2>
&lt;p>Docker是一个虚拟化容器引擎，跟虚拟机类似，不过更加轻量级。对于开发者来说，Docker的出现无疑是种福音。借助Docker，我们可以快速批量构建相同的环境，可以更加方便的对应用进行伸缩，以便更加灵活的控制应用的负载能力。我们还可以将其应用在开发中，使用Dockerfile快速构建统一的开发环境，避免因环境问题导致的BUG。许多云服务企业提供商业化的Docker容器资源，通过可定制的Dockerfile脚本来描述你需要的环境，以便快速构建生产环境和对生产环境进行伸缩控制。&lt;/p>
&lt;h2 id="dockerfile简介">Dockerfile简介&lt;/h2>
&lt;p>Dockerfile是Docker容器的“说明书”，用来描述Docker容器的构建过程。在同一份Dockerfile下，只能生成同一种环境，这种 &lt;code>唯一性&lt;/code> 一定程度上保证了应用运行在容器中的可靠性。&lt;/p>
&lt;p>Dockerfile的关键字只有寥寥几个，所以学习成本非常低。你可以很快速的学会Dockerfile的编写，但是要写出好的Dockerfile，还得多多琢磨。&lt;/p>
&lt;p>Dockerfile中常用的关键词大概就 &lt;code>FROM&lt;/code> &lt;code>RUN&lt;/code> &lt;code>WORKDIR&lt;/code> &lt;code>CMD&lt;/code> &lt;code>ENTRY&lt;/code> ，搞清楚它们的用法就基本学会了Dockerfile的编写方法，所以说它非常简单。&lt;/p>
&lt;h2 id="docker-compose简介">docker-compose简介&lt;/h2>
&lt;p>&lt;code>docker-compose&lt;/code> 是一种快速整合Docker容器的辅助工具，它通过读取 &lt;code>docker-compose.yml&lt;/code> 文件来分析其中所定义的各项 &lt;code>service&lt;/code> 之间关系，然后自动关联好。这大大简化了应用运行环境的构建，使我们可以更加方便的构建出完整的应用运行环境。&lt;/p>
&lt;blockquote>
&lt;p>大多数情况下，一个应用所需要依赖的服务都不止一个。以一个最基础的PHP应用来说，一般情况下至少会依赖 NginX MySQL PHP 三种软件，为了充分体现出容器化应用的优势，我们一般会将这三种软件独立构建成三种服务（service），然后相互关联起来（NginX关联PHP，PHP关联MySQL），这样一旦某一服务的负载过高，我们就可以通过使用相同的Dockerfile快速生成相同的服务，提高整个系统的吞吐能力。&lt;/p>
&lt;/blockquote>
&lt;h2 id="构建laravel开发环境">构建Laravel开发环境&lt;/h2>
&lt;h3 id="需求分析">需求分析&lt;/h3>
&lt;p>Laravel作为一个PHP应用框架，最基础的运行环境就是 &lt;code>LNMP&lt;/code> 。现代WEB应用的运行环境大多需要使用到NoSQL服务，所以一个 &lt;code>Redis&lt;/code> 服务就显得很有存在的必要了。&lt;/p>
&lt;p>所以需要构建的服务大致如下列：&lt;/p>
&lt;ul>
&lt;li>Linux&lt;/li>
&lt;li>NginX&lt;/li>
&lt;li>MySQL&lt;/li>
&lt;li>PHP&lt;/li>
&lt;li>Redis&lt;/li>
&lt;/ul>
&lt;h3 id="软件挑选">软件挑选&lt;/h3>
&lt;p>确定了要构建的服务，我们需要为服务所用软件挑选一个合适的版本，既不能太过”时髦“，也不能太过”守旧“。&lt;/p>
&lt;p>为了压缩生成好的容器的大小，我选择了 &lt;code>Alpine&lt;/code> 作为容器的系统，版本则选用其最新稳定版本3.4。&lt;/p>
&lt;blockquote>
&lt;p>Alpine是一个非常非常小的Linux系统，非常适合作为Docker容器的操作系统，其内置的包管理器存放了大部分常用软件，强烈推荐。&lt;/p>
&lt;/blockquote>
&lt;p>由于系统软件仓库的限制，以及对开发环境下的具体要求的考虑，其余软件都是直接使用官方仓库最新版本。&lt;/p>
&lt;h3 id="编写dockerfile">编写Dockerfile&lt;/h3>
&lt;p>因为是开发环境，不要求负载和伸缩能力，所以我将PHP和NginX放在一个容器中，这样可以方便配置NginX和PHP-FPM。&lt;/p>
&lt;p>取一个Redis容器的Dockerfile贴这方便看，当个例子吧。&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM alpine:3.4

RUN apk -f update
RUN apk -f add redis

COPY redis.conf /etc/redis.conf

EXPOSE 6379

CMD [&amp;#34;/usr/bin/redis-server&amp;#34;, &amp;#34;/etc/redis.conf&amp;#34;]
&lt;/code>&lt;/pre>&lt;h3 id="编写docker-composeyml">编写docker-compose.yml&lt;/h3>
&lt;p>容器的构建脚本编写好后，我们需要将各个容器关联起来，这样才能形成一个完整的应用运行环境。&lt;/p>
&lt;p>使用docker-compose来快速关联容器，示例如下：&lt;/p></description></item><item><title>Base32编码算法介绍及PHP实现</title><link>https://laeo.github.io/php/base32%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8Aphp%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 27 Jul 2016 00:00:00 +0000</pubDate><guid>https://laeo.github.io/php/base32%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8Aphp%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="什么是base32编码算法">什么是Base32编码算法&lt;/h2>
&lt;p>Base32不知道，那么Base64你肯定知道吧？它们都是用于对字符串数据进行编码的一种算法。Base64比Base32更加常见，PHP只内置了Base64编码算法的实现函数。如果不是研究 &lt;code>TOTP&lt;/code> 的时候发现谷歌的两步验证软件使用到了这种算法，我都不会知道有它。&lt;/p>
&lt;h2 id="有什么作用">有什么作用&lt;/h2>
&lt;p>限于我个人的认知范围，目前只知道谷歌两步验证功能中使用到了它。它与Base64是差不多的，差异只在于字符集的大小。&lt;/p>
&lt;h2 id="字符集哈希表">字符集哈希表&lt;/h2>
&lt;blockquote>
&lt;p>该字符集哈希表来源于算法文章 &lt;a href="https://tools.ietf.org/html/rfc4648">RFC4648&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>index&lt;/th>
 &lt;th>value&lt;/th>
 &lt;th>index&lt;/th>
 &lt;th>value&lt;/th>
 &lt;th>index&lt;/th>
 &lt;th>value&lt;/th>
 &lt;th>index&lt;/th>
 &lt;th>value&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>0&lt;/td>
 &lt;td>A&lt;/td>
 &lt;td>8&lt;/td>
 &lt;td>I&lt;/td>
 &lt;td>16&lt;/td>
 &lt;td>Q&lt;/td>
 &lt;td>24&lt;/td>
 &lt;td>Y&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>B&lt;/td>
 &lt;td>9&lt;/td>
 &lt;td>J&lt;/td>
 &lt;td>17&lt;/td>
 &lt;td>R&lt;/td>
 &lt;td>25&lt;/td>
 &lt;td>Z&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>C&lt;/td>
 &lt;td>10&lt;/td>
 &lt;td>K&lt;/td>
 &lt;td>18&lt;/td>
 &lt;td>S&lt;/td>
 &lt;td>26&lt;/td>
 &lt;td>2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>D&lt;/td>
 &lt;td>11&lt;/td>
 &lt;td>L&lt;/td>
 &lt;td>19&lt;/td>
 &lt;td>T&lt;/td>
 &lt;td>27&lt;/td>
 &lt;td>3&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4&lt;/td>
 &lt;td>E&lt;/td>
 &lt;td>12&lt;/td>
 &lt;td>M&lt;/td>
 &lt;td>20&lt;/td>
 &lt;td>U&lt;/td>
 &lt;td>28&lt;/td>
 &lt;td>4&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5&lt;/td>
 &lt;td>F&lt;/td>
 &lt;td>13&lt;/td>
 &lt;td>N&lt;/td>
 &lt;td>21&lt;/td>
 &lt;td>V&lt;/td>
 &lt;td>29&lt;/td>
 &lt;td>5&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6&lt;/td>
 &lt;td>G&lt;/td>
 &lt;td>14&lt;/td>
 &lt;td>O&lt;/td>
 &lt;td>22&lt;/td>
 &lt;td>W&lt;/td>
 &lt;td>30&lt;/td>
 &lt;td>6&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>7&lt;/td>
 &lt;td>H&lt;/td>
 &lt;td>15&lt;/td>
 &lt;td>P&lt;/td>
 &lt;td>23&lt;/td>
 &lt;td>X&lt;/td>
 &lt;td>31&lt;/td>
 &lt;td>7&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&lt;/p></description></item><item><title>TOTP原理介绍及PHP实现展示</title><link>https://laeo.github.io/php/totp%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8Aphp%E5%AE%9E%E7%8E%B0%E5%B1%95%E7%A4%BA/</link><pubDate>Tue, 26 Jul 2016 00:00:00 +0000</pubDate><guid>https://laeo.github.io/php/totp%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8Aphp%E5%AE%9E%E7%8E%B0%E5%B1%95%E7%A4%BA/</guid><description>&lt;h2 id="什么是-totp">什么是 “TOTP”&lt;/h2>
&lt;p>&lt;code>TOTP&lt;/code> 是 &lt;code>Time-based One-time Password&lt;/code> 的英文缩写，翻译为中文即“基于时间的一次性密码”。&lt;/p>
&lt;h2 id="有什么作用">有什么作用&lt;/h2>
&lt;p>快节奏的社会，一切讲究快捷、方便，但是安全相关，实在方便不起来， &lt;code>TOTP&lt;/code> 应运而生。使用该技术可以在降低身份认证复杂度的同时，将安全系数大幅度提高。君不见现在多少网站使用的动态口令功能，基本都是以该技术的为基础。Google Authenticator、Authy 等等软件都使用的该技术，我个人的域名注册商、服务器商也都接入了该技术。&lt;/p>
&lt;p>使用该技术来进行身份认证，可以加快认证速度，提高安全性。每个用户的认证口令是随着时间而变化的，无疑给 “黑手党” 们加大了许多难度。&lt;/p>
&lt;h2 id="totp-的原理">“TOTP” 的原理&lt;/h2>
&lt;p>该技术的着重点就在于基于时间，时间是不断变化的，所以基于时间而计算出来的 “密码” 也会是不断变化的。如果我们要使用该技术来进行身份认证，那么就一定要控制好时间变化的速度，否则时间无时无刻都在变化，我们如何进行认证？连输入密码也做不到吧。&lt;/p>
&lt;p>所以，控制时间是务必要做到的。那么，这就有点扯淡了。区区凡人还想控制时间？╭(╯^╰)╮&lt;/p>
&lt;p>看看下面的PHP代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$time&lt;/span> = time(); &lt;span style="color:#228b22">//取得实际时间，单位秒（unix时间戳）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$validity&lt;/span> = &lt;span style="color:#b452cd">30&lt;/span>; &lt;span style="color:#228b22">//设置动态密码有效期，给用户输入密码的时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#228b22">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00688b">$realtime&lt;/span> = &lt;span style="color:#00688b">$time&lt;/span> / &lt;span style="color:#00688b">$validity&lt;/span>; &lt;span style="color:#228b22">//相除得到 “真实时间”
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发明该算法的大师们很厉害，既然无法控制时间，那么我们就换个方式，变相控制时间。什么方式呢？除法！如果把时间看做被除数，把我们设置的密码有效期看做除数，把计算的结果看做我们取到的 &lt;code>真实时间&lt;/code> 。如此一来，每当 &lt;code>实际时间&lt;/code> 走过 &lt;code>密码有效期&lt;/code> 那么久后，我们取到的 &lt;code>真实时间&lt;/code> 的数值才会 &lt;code>+1&lt;/code> 。&lt;/p>
&lt;p>说到这里，如果我的表述没有问题的话，看官一定已经大致明白 &lt;code>TOTP&lt;/code> 到底如何实现了。使用这种方式取到的“时间”，就不必担心时间不停的流逝，毕竟只要没有超过密码有效期，该数值是不会变化的。&lt;/p>
&lt;p>细心的朋友一定注意到了，除法可能还有小数呢，到时候小数不停变化，不也一样影响最终结果么？&lt;/p>
&lt;p>这是肯定的，所以我推荐使用PHP内置的 &lt;code>floor()&lt;/code> 函数，该函数可以直接抹去浮点数的小数点后的部分。&lt;/p>
&lt;blockquote>
&lt;p>其实我自己使用的是 &lt;code>Math&lt;/code> 函数库提供的 &lt;code>intdiv()&lt;/code> 函数，效果都是一样的，甚至你可以直接 &lt;code>intval()&lt;/code> 。&lt;/p>
&lt;/blockquote>
&lt;h2 id="代码实例">代码实例&lt;/h2>
&lt;p>最主要的问题解决后，其它问题基本就不是问题了。下面附上实现代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-php" data-lang="php">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8b008b;font-weight:bold">class&lt;/span> &lt;span style="color:#008b45;font-weight:bold">TwoFactor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @var integer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">private&lt;/span> &lt;span style="color:#00688b">$delay&lt;/span> = &lt;span style="color:#b452cd">30&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @var string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">private&lt;/span> &lt;span style="color:#00688b">$secret&lt;/span> = &lt;span style="color:#8b008b;font-weight:bold">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * Create TwoFactor instance
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @param string $secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> __construct(&lt;span style="color:#00688b">$secret&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$this&lt;/span>-&amp;gt;&lt;span style="color:#658b00">secret&lt;/span> = &lt;span style="color:#00688b">$secret&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * Returns the authenticate code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @return string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">getCode&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$atom&lt;/span> = floor(time() / &lt;span style="color:#00688b">$this&lt;/span>-&amp;gt;&lt;span style="color:#658b00">delay&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$hash&lt;/span> = sha1(&lt;span style="color:#00688b">$this&lt;/span>-&amp;gt;&lt;span style="color:#658b00">secret&lt;/span> . dechex(&lt;span style="color:#00688b">$atom&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$last&lt;/span> = substr(&lt;span style="color:#00688b">$hash&lt;/span>, -&lt;span style="color:#b452cd">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$pos&lt;/span> = hexdec(&lt;span style="color:#00688b">$last&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$hex&lt;/span> = substr(&lt;span style="color:#00688b">$hash&lt;/span>, &lt;span style="color:#00688b">$pos&lt;/span>, &lt;span style="color:#b452cd">8&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00688b">$code&lt;/span> = (string) hexdec(&lt;span style="color:#00688b">$hex&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> substr(&lt;span style="color:#00688b">$code&lt;/span>, -&lt;span style="color:#b452cd">6&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cd5555">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * Try to authenticate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @param string $code
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> * @return boolean
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cd5555"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">public&lt;/span> &lt;span style="color:#8b008b;font-weight:bold">function&lt;/span> &lt;span style="color:#008b45">auth&lt;/span>(&lt;span style="color:#00688b">$code&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8b008b;font-weight:bold">return&lt;/span> (boolean) (strval(&lt;span style="color:#00688b">$code&lt;/span>) === &lt;span style="color:#00688b">$this&lt;/span>-&amp;gt;&lt;span style="color:#658b00">getCode&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;a href="https://github.com/laeo/totp">laeo/totp&lt;/a>&lt;/p></description></item></channel></rss>